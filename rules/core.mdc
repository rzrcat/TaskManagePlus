---
description: 
globs: 
alwaysApply: true
---
## [필수] 모든 구현/수정 시 이 컨벤션을 반드시 확인하고, 원칙에 맞춰 작업할 것!
# Core Convention (공용 컨벤션/구조/패턴/설계 원칙)

> 이 문서는 "공용 컨벤션(구조/패턴/설계/폴더/네이밍/타입 동기화/모듈화/재사용 등)"만을 다룹니다.
> 프로젝트 특화 정보/회고/진행 로그/주요 결정/아키텍처/프로세스 등은 memory-bank.mdc,
> 품질 관리/QA/테스트/자동화/체크리스트 등은 quality.mdc,
> 태스크 관리/운영/자동화/템플릿 등은 TaskManagerPlus/README.md에서만 관리합니다.

---

## 파일 관리 및 리팩토링 규칙

- **파일 위치 수정**: 리팩토링 시 파일이 올바르지 않은 위치에 있다면 적절한 위치로 이동합니다.
- **중복 파일 처리**: 중복된 파일이 발견되면 올바른 위치의 파일만 남기고 다른 파일은 삭제합니다.
- **지속적인 버그 발생**: 특정 구조에서 버그가 지속적으로 발생한다면 해당 부분을 새로운 구조로 변경하거나 완전히 재작성하는 방법을 고려합니다.
- **코드 변경 이력**: 파일 위치 변경이나 삭제 시 관련 내용을 PR 설명이나 커밋 메시지에 명시합니다.
- **점진적 리팩토링**: 대규모 변경 시 기능 단위로 점진적으로 리팩토링하여 서비스 안정성을 유지합니다.

## 타입 정의와 실제 데이터 구조 동기화 원칙

- **타입 정의와 실제 데이터 구조(DB/크롤러/API/프론트)는 항상 일치해야 합니다.**
- 타입스크립트 타입만 변경하거나, 실제 데이터 구조만 변경하는 패치는 금지합니다.
- 타입 정의를 변경할 경우, DB 스키마/크롤러/가공 코드/API/프론트엔드 타입/컴포넌트 등 **모든 계층을 동시에 동기화**해야 합니다.
- 타입-데이터 구조 mismatch가 발생하면 자동화 테스트/스크립트로 즉시 오류/경고/자동수정이 이루어집니다.
- 컨벤션 위반(타입-구조 불일치) 시 자동 경고 및 구조 추적·수정이 실행됩니다.
- 이 원칙은 모든 도메인(도감, 계산기, 트래커, 커뮤니티 등)과 공통 데이터에 일괄 적용됩니다.

## 훅 사용 규칙

- **훅 호출 순서**: React 훅은 항상 컴포넌트 최상위 레벨에서 호출되어야 하며, 조건문이나 반복문 내부에서 호출하지 않습니다.
- **조건부 로직**: 훅 내부에서 조건부 로직을 사용하고, 훅 자체를 조건부로 호출하지 않습니다.
- **커스텀 훅 네이밍**: 모든 커스텀 훅은 'use' 접두사로 시작하며 구체적인 기능을 나타내는 이름을 사용합니다.
- **훅 의존성 배열**: useEffect, useMemo, useCallback의 의존성 배열은 완전하게 작성하며, 필요 시 ESLint 규칙을 활용합니다.
- **서버/클라이언트 훅 분리**: 서버 컴포넌트에서 사용할 수 없는 훅(useState 등)은 명확히 구분하고 'use client' 지시문을 사용합니다.

## 모듈화 및 코드 재사용 원칙

### 모듈화 단위 정의

- **유틸 함수(Utility Function)**: 순수 로직, 데이터 변환, 계산 등을 담당 (상태나 렌더링과 무관)
- **커스텀 훅(Custom Hook)**: UI와 상태 관리 로직의 재사용 단위 (React 상태 관리와 연결)
- **컴포넌트(Component)**: UI 렌더링과 동작의 재사용 단위 (시각적 요소 포함)
- **서비스(Service)**: 외부 API 통신, 복잡한 비즈니스 로직 처리 등의 기능 단위

###  재사용 기준

- **유틸 함수**: 2개 이상의 컴포넌트에서 동일한 계산/변환 로직이 필요한 경우
- **커스텀 훅**: 2개 이상의 컴포넌트에서 동일한 상태 관리나 사이드 이펙트 로직이 필요한 경우
- **컴포넌트**: 3개 이상의 곳에서 유사한 UI와 동작이 필요한 경우
- **모듈 크기**: 500라인 이상인 파일은 기능별로 분할 검토

### 재사용 구현 원칙

- **단일 책임 원칙(SRP)**: 각 모듈은 하나의 기능만 담당하고, 하나의 이유로만 변경되어야 함
- **동일 기능 → 동일 로직**: 컴포넌트가 다르더라도 동일한 기능은 동일한 로직을 재사용
- **기능 기준 모듈화**: 컴포넌트는 유형이 아닌 '기능'을 기준으로 모듈화 (예: 카드 타입별로 나누기보다 다회차 진행 기능/단일 미션 기능으로 분류)
- **명확한 인터페이스**: 모듈 간 통신은 명확한 API/인터페이스로 제한
- **느슨한 결합(Loose Coupling)**: 모듈 간 직접적인 의존성 최소화, 인터페이스에만 의존
- **필요 최소 의존성**: 의존성은 꼭 필요한 것만 포함, 과도한 props/매개변수 지양
- **일관된 인터페이스**: 유사한 유틸/훅/컴포넌트는 일관된 인터페이스 유지
- **문서화**: 재사용 가능한 모든 요소는 간결한 JSDoc 설명 포함
- **추상화 계층 도입**: 구체적 구현보다 인터페이스에 의존하는 설계 채택

### 재사용 요소 위치

- **전역 재사용 요소**: `/src/shared` 또는 하위 적절한 폴더에 배치
- **도메인 특화 재사용 요소**: 해당 feature 폴더 내 적절한 위치에 배치
- **컴포넌트 내부 재사용 요소**: 컴포넌트 파일 내 helper 함수로 정의

### 피해야 할 안티패턴

- **거대 모듈(Blob Module)**: 하나의 모듈이 너무 많은 기능을 담당하는 경우
- **순환 의존성**: 모듈 간 A → B → C → A와 같은 의존성 구조 금지
- **과도한 추상화**: 실제 필요보다 많은 계층을 추가하여 가독성 저하
- **전역 상태 남용**: 필요 이상의 전역 상태 사용으로 추적 어려움 발생
- **인라인 스타일/로직 중복**: 공통 스타일이나 로직을 각 컴포넌트에 중복 작성
- **직접적 외부 의존성**: 인터페이스 없이 직접적으로 외부 모듈에 의존하는 구조

### 모듈화 테스트 전략

- **단위 테스트**: 각 모듈의 개별 기능 검증 (Jest, Testing Library)
- **통합 테스트**: 모듈 간 상호작용 검증 (Cypress, Playwright)
- **모의(Mock) 객체**: 외부 의존성을 가진 모듈 테스트 시 Mock 활용
- **테스트 커버리지**: 모듈 단위 80% 이상의 테스트 커버리지 목표

### React 특화 모듈화 패턴

- **컴포넌트 + Custom Hooks 분리**: UI와 로직의 명확한 분리
- **컨텍스트 API**: 적절한 범위의 상태 공유를 위한 Context 활용
- **컴포넌트 합성(Composition)**: 상속보다는 합성을 통한 컴포넌트 재사용
- **고차 컴포넌트(HOC)**: 횡단 관심사(인증, 로깅 등)를 분리하는 패턴 활용

## 버전 관리와 의존성 제어

### 모듈 버저닝

- **Semantic Versioning(MAJOR.MINOR.PATCH)** 원칙 준수
  - MAJOR: 하위 호환성이 깨지는 변경
  - MINOR: 하위 호환성을 유지하는 기능 추가
  - PATCH: 버그 수정 및 성능 개선
- **변경 이력 문서화**: 모든 주요 모듈/라이브러리의 변경 사항 기록

### 의존성 관리

- **명시적 버전 지정**: 패키지 매니저(npm)에서 정확한 버전 지정
- **Lock 파일 관리**: `package-lock.json` 파일 필수 커밋, 버전 충돌 방지
- **의존성 정기 검토**: 월 1회 이상 의존성 취약점 및 업데이트 필요성 검토
- **간접 의존성 주의**: 새 라이브러리 도입 시 간접 의존성 영향 고려
- **peer dependencies 관리**: 호환성 문제 방지를 위한 peer dependencies 명확화

### 의존성 최적화

- **트리 쉐이킹**: 사용하지 않는 코드 제거를 위한 import 최적화
- **지연 로딩**: 필요한 시점에만 모듈을 로드하는 dynamic import 활용
- **번들 크기 모니터링**: 새 의존성 추가 시 번들 크기 영향 검토

## 파일/구조/경로/자동화 관리 및 오류/스크립트 처리 원칙

- 파일/폴더/구조 변경(이동, 삭제, 생성, 수정, 이름 변경 등) 시 전체 프로젝트를 자동으로 스캔하여 실제 파일 존재, 위치, 중복, 누락, 참조(import/require/링크/문서/테스트/설정 등)를 일괄 점검 및 수정한다.
- 컨벤션(Feature-Sliced Design, shared/ui/atoms 등)에 맞는 위치로 이동/복구, 중복/누락/잘못된 위치 자동 처리한다.
- 자동화 스크립트/도구를 활용하며, 작업 전후에는 어떤 파일을 왜 읽거나 썼는지, 어떤 작업을 왜/어떻게 진행하는지 명확히 안내한다.
- 변경 이력(커밋/PR/개발 일지 등)은 반드시 명확히 기록한다.
- 심각한 데이터 손실, 대규모 삭제, 비가역적 변경 등은 반드시 사전 안내 및 승인 후 진행한다.
- 빌드, 테스트, 타입, import, 경로, 구조 등 모든 오류가 발생하면 자동으로 원인을 진단하고, 컨벤션에 맞게 직접 수정 작업을 즉시 진행한다.
- 자동으로 수정이 불가능하거나 복잡한 경우에는 필요한 스크립트(Node.js, bash 등)를 생성하여 직접 실행해 오류를 해결한다.
- 모든 자동화/스크립트 작업 전후에는 어떤 오류를 어떻게 수정하는지 명확하게 안내한다.
- 스크립트 실행 후에도 해결되지 않는 경우, 추가 안내 또는 수동 개입이 필요한 부분을 명확히 안내한다.

### 적용 예시/추가 안내
- import 오류 → 실제 파일 위치로 이동 및 경로 수정
- 파일 누락 → 유사 파일/컨벤션 기반 자동 생성 또는 안내
- 중복 파일 → 컨벤션 위치만 남기고 삭제
- 잘못된 위치 → 컨벤션 위치로 이동 및 경로 일괄 수정
- 자동 생성이 불가한 파일(예: 완전히 새 기능)은 어떤 파일이 필요한지 명확히 안내한다.

## 파일 자동 접근 및 수정 규칙

- 파일의 위치가 프로젝트 내에 있을 것으로 추정되는 경우(예: import 경로, 컨벤션상 위치, 유사 파일명 등)
  - 별도의 사용자 요청이나 승인 없이,
  - 자동으로 해당 파일을 읽고, 수정(생성/이동/삭제/내용 변경 등) 작업을 진행한다.
- 작업 전/후에는 어떤 파일을 왜 읽거나 썼는지 명확하게 안내한다.
- 파일이 실제로 존재하지 않거나, 자동 생성이 불가한 경우에만 사용자에게 추가 안내 또는 요청을 한다.

## 오류 수정 자동화 및 스크립트 생성 규칙

- 빌드, 테스트, 타입, import, 경로, 구조 등 모든 오류가 발생하면
  1. 자동으로 원인을 진단하고, 컨벤션에 맞게 직접 수정 작업을 즉시 진행한다.
  2. 자동으로 수정이 불가능하거나 복잡한 경우에는
     - 스스로 필요한 스크립트(예: Node.js, bash 등)를 생성하여
     - 해당 스크립트를 직접 실행해 오류를 해결한다.
- 모든 자동화/스크립트 작업 전후에는 어떤 오류를 어떻게 수정하는지 명확하게 안내한다.
- 스크립트 실행 후에도 해결되지 않는 경우, 추가 안내 또는 수동 개입이 필요한 부분을 명확히 안내한다.

## 13. 자동화 우선 작업 및 사전/사후 안내 원칙

- 프로젝트에 심각한 문제(데이터 손실, 대규모 기능 삭제, 비가역적 변경 등)를 야기하지 않는 한,  
  직접적인 수동 개입 없이 모든 구조/경로/중복/누락/머지 충돌/빌드 오류/컨벤션 위반 등 문제를  
  **자동으로 진단, 수정, 이동, 생성, 삭제, 경로 변경 등 필요한 작업을 즉시 진행**한다.

- 모든 자동 작업은  
  "어떤 작업을 왜, 어떻게 진행하는지"  
  작업 전/후 또는 작업 중간에  
  **명확하게 설명**한다.

- 심각한 데이터 손실, 대규모 삭제, 비가역적 변경 등은 반드시 사전 안내 및 승인 후 진행한다.
- 자동화 우선, 사전 설명 및 사후 보고 원칙을 따른다.

## 20. 자동화 스크립트 관리 원칙

- 자동화/임시/유틸리티 스크립트(`scripts/` 하위에 생성된 _.js, _.ts 등)는 실행 후 즉시 삭제한다.
- 작업 이력 및 결과는 커밋/대화/문서로만 남기고, 불필요한 임시 파일이 프로젝트에 남지 않도록 한다.
- 이 원칙은 모든 자동화/임시 스크립트 작업에 일관되게 적용한다.


## 23. 파일 삭제/이름/위치 변경 시 연관성 자동 점검 및 일괄 수정 원칙

- 파일을 삭제, 이름 변경, 위치 이동할 때는 프로젝트 전체를 자동으로 점검하여
  - 해당 파일을 참조하는 모든 import, require, 경로, 링크, 문서, 테스트, 설정 파일 등을 일괄 
  수정한다.
- 변경된 파일 경로/이름이 반영되지 않은 곳이 없도록 자동화 스크립트 또는 도구를 활용한다.
- 변경 이력은 커밋 메시지, PR, 개발 일지 등에 반드시 명확히 기록한다.
- 이 원칙은 코드, 문서, 테스트, 설정 등 모든 파일에 일괄 적용한다.
